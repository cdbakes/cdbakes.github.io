type Atom = {
  x: number;
  y: number;
  z: number;
  element: string;
}

type Bond = {
  from: number;
  to: number;
  type: number;
}

type MoleculeData = {
  atoms: Atom[];
  bonds: Bond[];
  atomCount: number;
  bondCount: number;
}

const parseSDF = (sdfContent: string): MoleculeData => {
  const lines = sdfContent.split('\n');
  
  // Parse counts line (line 4)
  const countsLine = lines[3].trim();
  const atomCount = parseInt(countsLine.substring(0, 3));
  const bondCount = parseInt(countsLine.substring(3, 6));

  const atoms: Atom[] = [];
  const bonds: Bond[] = [];

  // Parse atoms (start at line 5)
  for (let i = 0; i < atomCount; i++) {
    const line = lines[i + 4];  // Don't trim, need exact positions
    atoms.push({
      x: parseFloat(line.substring(0, 10).trim()),
      y: parseFloat(line.substring(10, 20).trim()),
      z: parseFloat(line.substring(20, 30).trim()),
      element: line.substring(31, 34).trim()
    });
  }

  // Parse bonds (start after atoms)
  for (let i = 0; i < bondCount; i++) {
    const line = lines[i + 4 + atomCount];  // Don't trim, need exact positions
    // Bonds are in fixed-width fields of 3 characters each
    const from = parseInt(line.substring(0, 3).trim()) - 1;  // Convert to 0-based indexing
    const to = parseInt(line.substring(3, 6).trim()) - 1;    // Convert to 0-based indexing
    const type = parseInt(line.substring(6, 9).trim());      // Bond type
    
    // Validate bond indices
    if (from >= 0 && to >= 0 && from < atomCount && to < atomCount) {
      bonds.push({ from, to, type });
    } else {
      console.warn(`Invalid bond indices: ${from + 1}-${to + 1}`);
    }
  }

  return {
    atoms,
    bonds,
    atomCount,
    bondCount: bonds.length // Use actual number of valid bonds
  };
};

const normalizePositions = (positions: { x: number; y: number; z: number }[]) => {
  // Find the center point
  const center = positions.reduce(
    (acc, pos) => ({
      x: acc.x + pos.x / positions.length,
      y: acc.y + pos.y / positions.length,
      z: acc.z + pos.z / positions.length,
    }),
    { x: 0, y: 0, z: 0 }
  );

  // Center the positions around origin
  const centered = positions.map(pos => ({
    x: pos.x - center.x,
    y: pos.y - center.y,
    z: pos.z - center.z,
  }));

  // Find the maximum distance from origin
  const maxDist = Math.sqrt(
    Math.max(
      ...centered.map(
        pos => pos.x * pos.x + pos.y * pos.y + pos.z * pos.z
      )
    )
  );

  // Normalize to range [-0.5, 0.5]
  return centered.map(pos => ({
    x: pos.x / (maxDist * 1.5),  // Slightly larger scale for better visibility
    y: pos.y / (maxDist * 1.5),
    z: pos.z / (maxDist * 1.5),
  }));
};

const generateMoleculeConstants = (data: MoleculeData): string => {
  // Normalize atom positions
  const positions = normalizePositions(data.atoms.map(atom => ({
    x: atom.x,
    y: atom.y,
    z: atom.z
  })));

  // Create bonds array with comments
  const bonds = data.bonds.map(bond => 
    `  [${bond.from}, ${bond.to}], // Bond ${bond.from + 1}-${bond.to + 1} (${bond.type === 2 ? 'double' : 'single'})`
  );

  // Create positions array with comments
  const atomPositions = positions.map((pos, i) => 
    `  { x: ${pos.x.toFixed(4)}, y: ${pos.y.toFixed(4)}, z: ${pos.z.toFixed(4)} },   // ${i}`
  );

  return `// This file is auto-generated by the updateMoleculeConstants script
// Do not edit directly

export const MOLECULE_BONDS: [number, number][] = [
${bonds.join('\n')}
];

export interface AtomPosition {
  x: number;
  y: number;
  z: number;
}

export const ATOM_POSITIONS: AtomPosition[] = [
${atomPositions.join('\n')}
];`;
};

export { parseSDF, generateMoleculeConstants };
